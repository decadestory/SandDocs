<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2.笔记本/GO架构知识总结</title>
    <link rel="stylesheet" href="../../resource/theme/yuan-shan.css">
    <link rel="stylesheet" href="../../resource/css/base.css">
</head>
<body>
    <div class="markdow">
        <div class="markdow-list">
             <div class="header">
                <img class="logo" src="../../resource/image/logo.jpg"/>
                <div>JERRY♎<a href="https://github.com/decadestory" target="_blank" >GITHUB</a></div>
            </div>
            <div class="type">
                <ul>
                    <li><a href="../../docs_list/1.SandDocs.html">SandDocs</a></li><li><a href="../../docs_list/2.笔记本.html">笔记本</a></li><li><a href="../../docs_list/4.HISTORY.html">HISTORY</a></li><li><a href="../../docs_list/5.平衡.html">平衡</a></li><li><a href="../../docs_list/6.一些小诗.html">一些小诗</a></li><li><a href="../../docs_list/7.关于JERRY.html">关于JERRY</a></li>
                </ul>
            </div>
        </div>
        <div class="markdow-container">
            <div class="markdow-content">
                <h1>GO架构知识总结</h1>
<!-- raw HTML omitted -->
<h2>一、GO基础</h2>
<h3>0. 程序，进程，线程，协程是什么</h3>
<ul>
<li><em>程序</em> 是一个静态的、保存在磁盘上的可执行文件，例如 .exe、.out 文件。它是代码 + 数据 + 资源的集合，但本身 还没有被执行，只是“潜力股”。</li>
<li><em>进程</em> 是程序运行起来的实例，是操作系统资源分配的最小单位。独立的内存空间</li>
<li><em>线程</em> 是操作系统调度的最小单位。一个进程可以有多个线程，它们 共享进程的内存资源（堆、全局变量），但每个线程有自己的栈空间。</li>
<li><em>协程</em> 是用户态的线程，也叫轻量级线程。它由程序自己调度，而不是操作系统调度。 协程之间切换开销小，不需要内核态切换，一个 G 初始只占几 KB 堆栈</li>
</ul>
<h3>1.GMP模型</h3>
<ul>
<li>
<p>G	Goroutine	协程（数以百万计）-任务</p>
</li>
<li>
<p>M	Machine	内核线程（OS Thread） -工人 （OS 线程）</p>
</li>
<li>
<p>P	Processor	执行上下文（逻辑处理器）-工作台（任务队列）</p>
</li>
<li>
<p>golang调度器调度</p>
</li>
<li>
<p>如果没有 G 可跑P 会去 全局队列或 别的 P 的队列偷任务（Work Stealing）</p>
</li>
</ul>
<h3>2. 垃圾回收-三色标记</h3>
<ul>
<li>
<p>白色	未访问对象（可能是垃圾）</p>
</li>
<li>
<p>灰色	已访问但字段未扫描的对象（待处理）</p>
</li>
<li>
<p>黑色	已访问且字段也已扫描完的对象（活对象）</p>
<ul>
<li>
<p>1.初始化阶段： 所有对象都标为白色。<!-- raw HTML omitted --></p>
</li>
<li>
<p>2.根对象入灰： GC 从根对象（全局变量、栈上的变量等）开始，把它们标记为灰色，加入“灰色队列”。<!-- raw HTML omitted --></p>
</li>
<li>
<p>3.标记阶段：<!-- raw HTML omitted --></p>
</li>
<li>
<p>每次从灰色队列中取出一个对象：<!-- raw HTML omitted --></p>
<ul>
<li>标为黑色<!-- raw HTML omitted --></li>
<li>把它引用的白色对象标为灰色，加入灰色队列<!-- raw HTML omitted --></li>
</ul>
</li>
<li>
<p>直到灰色队列为空<!-- raw HTML omitted --></p>
</li>
<li>
<p>4.清除阶段：</p>
</li>
<li>
<p>剩下白色的对象就是“不可达的垃圾”，回收掉。<!-- raw HTML omitted --></p>
</li>
<li>
<p>主要是找标记已引用的对象，清掉未引用的对象</p>
</li>
</ul>
</li>
</ul>
<h3>3. channel</h3>
<ul>
<li>channel 是 Go 中的一种类型，用于在多个 goroutine 之间安全地传递数据，遵循 通信顺序一致性原则</li>
</ul>
<h3>4. sync.RwMutex</h3>
<ul>
<li>mu.RLock() 会给 mu 这个 sync.RWMutex 加“读锁”，表示当前有一个读操作正在进行。多个读锁之间是并发的，但一旦有写锁存在或等待，读锁必须等待。</li>
</ul>
<h3>5. sync.Cond，sync.Map，sync.Once</h3>
<ul>
<li>sync.Cond 条件变量，用于协程间的等待与通知</li>
<li>sync.Map 并发安全的 map</li>
<li>sync.Once 确保某段代码只执行一次，常用于 单例模式、惰性初始化、只调用一次的清理逻辑</li>
</ul>
<h2>二、分布式锁</h2>
<ul>
<li>基于 Redis 的分布式锁（最常见）</li>
<li>使用 etcd 实现分布式锁</li>
<li>使用 ZooKeeper 的分布式锁 ZooKeeper 锁比较重型，Go 通常不首选。</li>
</ul>
<h2>三、分布式事务</h2>
<ul>
<li>
<p>DTM (Distributed Transaction Manager) 是 Go 语言开发的轻量级分布式事务框架，支持 TCC、SAGA、XA、消息事务。</p>
</li>
<li>
<p>TCC（Try-Confirm-Cancel）	业务自定义三阶段逻辑	强一致性 / 可控最终一致	中等	中高	✅ 支持自定义回滚	金融、下单、扣库存等需预留资源的场景</p>
</li>
<li>
<p>SAGA	正向链式调用 + 补偿（无锁）	最终一致	中	高	✅ 补偿函数（逆操作）	电商、流程审批、跨服务资源变更</p>
</li>
<li>
<p>消息事务（事务消息）	本地事务 + MQ 消息（可靠发送）	最终一致	简单	高	✅ 重试机制	异步事件通知、邮件发送、记账</p>
</li>
<li>
<p>XA（两阶段提交）	标准 2PC 协议，数据库驱动支持	强一致性	高	低	✅ 自动回滚	银行、支付、主库一致性写入</p>
</li>
<li>
<p>事务屏障（Barrier）	幂等 + 空补偿 + 防悬挂机制	辅助机制	辅助	中高	✅ 多模型可用	防止接口幂等性问题、支持重复提交</p>
</li>
<li>
<p><img src="/resource/image/image.png" alt="alt text"></p>
</li>
</ul>
<h2>四、Mysql相关</h2>
<h2>五、Redis相关</h2>
<h2>五、消息队列</h2>

            </div>
        </div>   
    </div>
</body>
</html>